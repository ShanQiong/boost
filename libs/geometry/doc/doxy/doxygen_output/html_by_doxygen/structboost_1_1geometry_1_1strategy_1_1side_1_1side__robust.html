<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Geometry (aka GGL, Generic Geometry Library)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.Geometry" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1geometry_1_1strategy.html">strategy</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1geometry_1_1strategy_1_1side.html">side</a></li><li class="navelem"><a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html">side_robust</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::geometry::strategy::side::side_robust&lt; CalculationType, EqualsPolicy, Robustness &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__strategies.html">strategies: strategies</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Adaptive precision predicate to check at which side of a segment a point lies: left of segment (&gt;0), right of segment (&lt; 0), on segment (0).  
 <a href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust_1_1epsilon__policy.html">epsilon_policy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a41d1dfe09d83ab13f84dd88eef1e53"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1geometry_1_1cartesian__tag.html">cartesian_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html#a3a41d1dfe09d83ab13f84dd88eef1e53">cs_tag</a></td></tr>
<tr class="separator:a3a41d1dfe09d83ab13f84dd88eef1e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ace8f73d22c0a935ea01e406a3fc3fc76"><td class="memTemplParams" colspan="2">template&lt;typename PromotedType , typename P1 , typename P2 , typename P , typename EpsPolicyInternal , std::enable_if_t&lt; std::is_fundamental&lt; PromotedType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ace8f73d22c0a935ea01e406a3fc3fc76"><td class="memTemplItemLeft" align="right" valign="top">static PromotedType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html#ace8f73d22c0a935ea01e406a3fc3fc76">side_value</a> (P1 const &amp;p1, P2 const &amp;p2, P const &amp;p, EpsPolicyInternal &amp;eps_policy)</td></tr>
<tr class="memdesc:ace8f73d22c0a935ea01e406a3fc3fc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sign of the CCW triangle p1, p2, p.  <a href="#ace8f73d22c0a935ea01e406a3fc3fc76">More...</a><br /></td></tr>
<tr class="separator:ace8f73d22c0a935ea01e406a3fc3fc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cbbd9fcf392b87c29164cadf8bea32"><td class="memTemplParams" colspan="2">template&lt;typename PromotedType , typename P1 , typename P2 , typename P , typename EpsPolicyInternal , std::enable_if_t&lt;!std::is_fundamental&lt; PromotedType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a85cbbd9fcf392b87c29164cadf8bea32"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html#a85cbbd9fcf392b87c29164cadf8bea32">side_value</a> (P1 const &amp;p1, P2 const &amp;p2, P const &amp;p, EpsPolicyInternal &amp;)</td></tr>
<tr class="separator:a85cbbd9fcf392b87c29164cadf8bea32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CalculationType = void, typename EqualsPolicy = epsilon_equals_policy, std::size_t Robustness = 3&gt;<br />
struct boost::geometry::strategy::side::side_robust&lt; CalculationType, EqualsPolicy, Robustness &gt;</h3>

<p>Adaptive precision predicate to check at which side of a segment a point lies: left of segment (&gt;0), right of segment (&lt; 0), on segment (0). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CalculationType</td><td>numeric type for calculation (e.g. high precision); if [*void] then it is extracted automatically from the coordinate type and (if necessary) promoted to floating point (numeric_limits&lt;ct&gt;::epsilon() and numeric_limits&lt;ct&gt;::digits must be supported for calculation type ct) </td></tr>
    <tr><td class="paramname">Robustness</td><td>std::size_t value from 0 (fastest) to 3 (default, guarantees correct results).</td></tr>
  </table>
  </dd>
</dl>
<p>This predicate determines at which side of a segment a point lies using an algorithm that is adapted from orient2d as described in "Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates" by Jonathan Richard Shewchuk ( <a href="https://dl.acm.org/citation.cfm?doid=237218.237337">https://dl.acm.org/citation.cfm?doid=237218.237337</a> ). More information and copies of the paper can also be found at <a href="https://www.cs.cmu.edu/~quake/robust.html">https://www.cs.cmu.edu/~quake/robust.html</a> . It is designed to be adaptive in the sense that it should be fast for inputs that lead to correct results with plain float operations but robust for inputs that require higher precision arithmetics. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3a41d1dfe09d83ab13f84dd88eef1e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a41d1dfe09d83ab13f84dd88eef1e53">&#9670;&nbsp;</a></span>cs_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CalculationType  = void, typename EqualsPolicy  = epsilon_equals_policy, std::size_t Robustness = 3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1geometry_1_1cartesian__tag.html">cartesian_tag</a> <a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html">boost::geometry::strategy::side::side_robust</a>&lt; CalculationType, EqualsPolicy, Robustness &gt;::<a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html#a3a41d1dfe09d83ab13f84dd88eef1e53">cs_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace8f73d22c0a935ea01e406a3fc3fc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8f73d22c0a935ea01e406a3fc3fc76">&#9670;&nbsp;</a></span>side_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CalculationType  = void, typename EqualsPolicy  = epsilon_equals_policy, std::size_t Robustness = 3&gt; </div>
<div class="memtemplate">
template&lt;typename PromotedType , typename P1 , typename P2 , typename P , typename EpsPolicyInternal , std::enable_if_t&lt; std::is_fundamental&lt; PromotedType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PromotedType <a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html">boost::geometry::strategy::side::side_robust</a>&lt; CalculationType, EqualsPolicy, Robustness &gt;::side_value </td>
          <td>(</td>
          <td class="paramtype">P1 const &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2 const &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpsPolicyInternal &amp;&#160;</td>
          <td class="paramname"><em>eps_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sign of the CCW triangle p1, p2, p. </p>

</div>
</div>
<a id="a85cbbd9fcf392b87c29164cadf8bea32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cbbd9fcf392b87c29164cadf8bea32">&#9670;&nbsp;</a></span>side_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CalculationType  = void, typename EqualsPolicy  = epsilon_equals_policy, std::size_t Robustness = 3&gt; </div>
<div class="memtemplate">
template&lt;typename PromotedType , typename P1 , typename P2 , typename P , typename EpsPolicyInternal , std::enable_if_t&lt;!std::is_fundamental&lt; PromotedType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="structboost_1_1geometry_1_1strategy_1_1side_1_1side__robust.html">boost::geometry::strategy::side::side_robust</a>&lt; CalculationType, EqualsPolicy, Robustness &gt;::side_value </td>
          <td>(</td>
          <td class="paramtype">P1 const &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2 const &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpsPolicyInternal &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>April 2, 2011</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2007-2011 Barend Gehrels, Amsterdam, the Netherlands<br>
Copyright &copy; 2008-2011 Bruno Lalande, Paris, France<br>
Copyright &copy; 2009-2010 Mateusz Loskot, London, UK<br>
</small>
</td>
</tr>
</tbody>
</table>
<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>